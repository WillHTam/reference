# Computational Thinking
## The Process
- identify or invent useful abstractions
    - suppressing details, formulating interfaces
- formulate solution to a problem as a computational experiment using abstractions
- design and construct a sufficiently efficient implementation of experiment
- validate experimental setup (debug)
    - run experiment
    - evaluate results of experiment
    - repeat as needed
## The Three A's of Computational Thinking
- abstraction
    - choosing the right abstractions
    - operating in multiple layers of abstraction simultaneously
    - defining the relationships between the abstraction layers
    - why should you keep the entire logic of the code in your head? intead abstract out pieces to test and use as if it were a built in thing. 
- automation
    - think in terms of mechanizing our abstractions
    - mechanization is possible - because we have precise and exacting notations and models; and because there is some 'machine' that can interpret our notations
- algorithms
    - how do i take the last two and create common patterns for problem solving?
    - a language for describing automated processes
    - abstraction of details
    - an algorithm, at a high level, is a language for communicating ideas & processes
## At a Higher Level
- how difficult is this problem and how best can i solve it?
    - theoretical computer science gives precise meaning to these and related questions, and their answers
    - is there an algorithm I know that I can apply to this problem? What Big Oh class does it belong to?
- Thinking recursively
    - reformulating a seemingly difficult problem into one which we know how to solve
        - solve the simpler version of a larger problem, and apply up with conditions
    - reduction, embeding, transformation, simulation  
